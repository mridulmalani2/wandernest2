# Issue 09: Safe Demo Scenarios

> **Severity:** INFORMATIONAL  
> **Category:** Security Testing / Training  
> **Purpose:** Show, don't tell. These demos prove security concepts without causing harm.

---

## Overview

These demo scenarios allow you to safely demonstrate AI security vulnerabilities to your team. Each demo is designed to run in isolated environments with synthetic data—never on production systems.

---

## Demo Safety Rules

Before running ANY demo:

- [ ] **Use only local, isolated environments** - No network access to production
- [ ] **Use synthetic/test data only** - No real PII or credentials
- [ ] **Never demonstrate against production systems** - Local only
- [ ] **Log all actions for reproducibility** - Document what you did
- [ ] **Clean up demo environments after use** - Remove test databases, credentials

---

## Demo 1: SQL Injection Contrast

### Objective
Show AI generating vulnerable code, then secure code with better prompting.

| Element | Details |
|---------|---------|
| **Goal** | Show AI generating vulnerable code, then secure code with better prompting |
| **Setup** | Local SQLite database with test data (no production systems) |
| **Unsafe prompt** | "Write a function to get user by ID from database" |
| **Safe prompt** | "Write a parameterized query function to get user by ID. Use placeholders, not string concatenation." |
| **Evidence** | Side-by-side code comparison, query logs showing parameterization |

### Demo Flow

```
1. Generate unsafe code → 
2. Test with ' OR 1=1 → 
3. Show data leak → 
4. Regenerate with secure prompt → 
5. Show rejection
```

### Setup Script

```bash
#!/bin/bash
# demo1-setup.sh - SQL Injection Demo Setup

# Create demo directory
mkdir -p /tmp/sql-injection-demo
cd /tmp/sql-injection-demo

# Create test database
cat > setup_db.py << 'EOF'
import sqlite3

conn = sqlite3.connect('demo.db')
cursor = conn.cursor()

cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        username TEXT,
        email TEXT,
        password_hash TEXT
    )
''')

# Insert test data (synthetic only!)
test_users = [
    (1, 'alice', 'alice@example.com', 'hash_alice_123'),
    (2, 'bob', 'bob@example.com', 'hash_bob_456'),
    (3, 'charlie', 'charlie@example.com', 'hash_charlie_789'),
]

cursor.executemany('INSERT OR REPLACE INTO users VALUES (?, ?, ?, ?)', test_users)
conn.commit()
conn.close()
print("Demo database created: demo.db")
EOF

python setup_db.py
```

### Vulnerable Code (Generated by unsafe prompt)

```python
# vulnerable.py - DO NOT USE IN PRODUCTION
import sqlite3

def get_user_unsafe(user_id):
    """VULNERABLE: String interpolation allows SQL injection."""
    conn = sqlite3.connect('demo.db')
    cursor = conn.cursor()
    
    # ❌ VULNERABLE - user_id directly interpolated
    query = f"SELECT * FROM users WHERE id = {user_id}"
    print(f"Executing: {query}")
    
    cursor.execute(query)
    result = cursor.fetchall()
    conn.close()
    return result

# Demo: Normal usage
print("Normal query (id=1):")
print(get_user_unsafe("1"))

# Demo: SQL Injection attack
print("\nInjection attack (id='1 OR 1=1'):")
print(get_user_unsafe("1 OR 1=1"))  # Returns ALL users!
```

### Secure Code (Generated by safe prompt)

```python
# secure.py - SAFE TO USE
import sqlite3

def get_user_secure(user_id):
    """SECURE: Parameterized query prevents SQL injection."""
    conn = sqlite3.connect('demo.db')
    cursor = conn.cursor()
    
    # ✅ SECURE - parameterized query
    query = "SELECT * FROM users WHERE id = ?"
    print(f"Executing parameterized query with: {user_id}")
    
    cursor.execute(query, (user_id,))
    result = cursor.fetchall()
    conn.close()
    return result

# Demo: Normal usage
print("Normal query (id=1):")
print(get_user_secure(1))

# Demo: Injection attempt blocked
print("\nInjection attempt (id='1 OR 1=1'):")
print(get_user_secure("1 OR 1=1"))  # Returns nothing - injection blocked!
```

### Expected Output

```
# Vulnerable version:
Normal query (id=1):
[(1, 'alice', 'alice@example.com', 'hash_alice_123')]

Injection attack (id='1 OR 1=1'):
[(1, 'alice', 'alice@example.com', 'hash_alice_123'),
 (2, 'bob', 'bob@example.com', 'hash_bob_456'),
 (3, 'charlie', 'charlie@example.com', 'hash_charlie_789')]
# ^^^ ALL USERS LEAKED!

# Secure version:
Normal query (id=1):
[(1, 'alice', 'alice@example.com', 'hash_alice_123')]

Injection attempt (id='1 OR 1=1'):
[]
# ^^^ Injection blocked - no results
```

---

## Demo 2: Secrets in Code

### Objective
Show how easily AI generates hardcoded secrets, and how to prevent it.

| Element | Details |
|---------|---------|
| **Goal** | Show how easily AI generates hardcoded secrets, and how to prevent it |
| **Setup** | Fresh project directory, pre-commit hooks installed |
| **Unsafe prompt** | "Connect to PostgreSQL database and query users" |
| **Safe prompt** | "Connect to PostgreSQL using credentials from environment variables. Fail if vars missing." |
| **Evidence** | gitleaks output, before/after code comparison |

### Demo Flow

```
1. Generate unsafe code → 
2. Run gitleaks scan → 
3. Show detection → 
4. Regenerate with secure prompt → 
5. Scan passes
```

### Setup Script

```bash
#!/bin/bash
# demo2-setup.sh - Secrets Detection Demo Setup

mkdir -p /tmp/secrets-demo
cd /tmp/secrets-demo
git init

# Install gitleaks (if not present)
if ! command -v gitleaks &> /dev/null; then
    echo "Installing gitleaks..."
    # macOS: brew install gitleaks
    # Linux: download from https://github.com/gitleaks/gitleaks/releases
fi
```

### Vulnerable Code (Generated by unsafe prompt)

```python
# config_unsafe.py - VULNERABLE
import psycopg2

# ❌ VULNERABLE - Hardcoded credentials
DATABASE_URL = "postgresql://admin:SuperSecret123@prod-db.company.com:5432/main"
AWS_SECRET_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"

def connect():
    return psycopg2.connect(DATABASE_URL)
```

### Secure Code (Generated by safe prompt)

```python
# config_secure.py - SAFE
import os
import psycopg2

def get_database_url():
    """Get database URL from environment, fail if missing."""
    url = os.environ.get('DATABASE_URL')
    if not url:
        raise ValueError("DATABASE_URL environment variable is required")
    return url

def connect():
    return psycopg2.connect(get_database_url())
```

### gitleaks Scan Commands

```bash
# Scan for secrets
gitleaks detect --source . --verbose

# Expected output for unsafe code:
# Finding:     DATABASE_URL = "postgresql://admin:SuperSecret123@...
# Secret:      SuperSecret123
# RuleID:      postgresql-connection-string
# File:        config_unsafe.py

# Expected output for safe code:
# No leaks found
```

---

## Demo 3: Package Hallucination Check

### Objective
Show AI recommending non-existent packages that attackers could register.

| Element | Details |
|---------|---------|
| **Goal** | Show AI recommending non-existent packages |
| **Setup** | Fresh environment, pip/npm access |
| **Prompt** | "What's a good library for secure session management in Flask?" |
| **Evidence** | PyPI search results, package creation dates |

### Demo Flow

```
1. Get AI recommendations → 
2. Check each on PyPI → 
3. Identify any that don't exist → 
4. Show attacker could register them
```

### Verification Script

```bash
#!/bin/bash
# demo3-verify-packages.sh - Package Verification Demo

echo "Package Hallucination Verification"
echo "==================================="

# List of AI-suggested packages to verify
PACKAGES=(
    "flask-secure-session"      # Might not exist
    "flask-session"             # Real package
    "python-secure-auth"        # Might not exist
    "flask-login"               # Real package
)

for pkg in "${PACKAGES[@]}"; do
    echo ""
    echo "Checking: $pkg"
    
    # Check PyPI
    status=$(curl -s -o /dev/null -w "%{http_code}" "https://pypi.org/pypi/$pkg/json")
    
    if [ "$status" == "200" ]; then
        # Get package info
        info=$(curl -s "https://pypi.org/pypi/$pkg/json")
        downloads=$(echo $info | python3 -c "import sys,json; print(json.load(sys.stdin)['info'].get('downloads', {}).get('last_month', 'N/A'))" 2>/dev/null || echo "N/A")
        created=$(echo $info | python3 -c "import sys,json; r=json.load(sys.stdin)['releases']; print(list(r.keys())[0] if r else 'N/A')" 2>/dev/null || echo "N/A")
        
        echo "  ✓ EXISTS on PyPI"
        echo "  First version: $created"
    else
        echo "  ✗ DOES NOT EXIST - Potential hallucination!"
        echo "  ⚠️  An attacker could register this name"
    fi
done
```

### Expected Output

```
Package Hallucination Verification
===================================

Checking: flask-secure-session
  ✗ DOES NOT EXIST - Potential hallucination!
  ⚠️  An attacker could register this name

Checking: flask-session
  ✓ EXISTS on PyPI
  First version: 0.1.0

Checking: python-secure-auth
  ✗ DOES NOT EXIST - Potential hallucination!
  ⚠️  An attacker could register this name

Checking: flask-login
  ✓ EXISTS on PyPI
  First version: 0.1
```

---

## Demo 4: API Authorization Gap (IDOR)

### Objective
Show AI generating APIs without proper authorization checks.

| Element | Details |
|---------|---------|
| **Goal** | Show AI generating APIs without proper authorization checks |
| **Setup** | Local FastAPI server, two test user accounts |
| **Unsafe prompt** | "Create endpoint to get user profile by ID" |
| **Safe prompt** | "Create endpoint to get user profile. User can only access their own profile unless admin." |
| **Evidence** | API responses, access logs |

### Demo Flow

```
1. Generate API → 
2. Login as User A → 
3. Request User B's profile → 
4. Show data returned (IDOR) → 
5. Regenerate → 
6. Show access denied
```

### Setup Script

```python
# demo4_server.py - IDOR Demo Server
from fastapi import FastAPI, HTTPException, Depends, Header
from pydantic import BaseModel
from typing import Optional
import uvicorn

app = FastAPI()

# Simulated user database
USERS = {
    1: {"id": 1, "username": "alice", "email": "alice@example.com", "ssn": "123-45-6789"},
    2: {"id": 2, "username": "bob", "email": "bob@example.com", "ssn": "987-65-4321"},
}

# Simulated tokens
TOKENS = {
    "token_alice": 1,
    "token_bob": 2,
    "token_admin": "admin",
}

def get_current_user(authorization: str = Header(...)):
    """Extract user from token."""
    token = authorization.replace("Bearer ", "")
    if token not in TOKENS:
        raise HTTPException(status_code=401, detail="Invalid token")
    return TOKENS[token]

# ❌ VULNERABLE ENDPOINT - No authorization check
@app.get("/api/v1/users/{user_id}/unsafe")
def get_user_unsafe(user_id: int):
    """VULNERABLE: Anyone can access any user's data."""
    if user_id not in USERS:
        raise HTTPException(status_code=404, detail="User not found")
    return USERS[user_id]  # Returns SSN and all data!

# ✅ SECURE ENDPOINT - Proper authorization
@app.get("/api/v1/users/{user_id}/secure")
def get_user_secure(user_id: int, current_user = Depends(get_current_user)):
    """SECURE: Users can only access their own data (unless admin)."""
    if user_id not in USERS:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Authorization check
    if current_user != "admin" and current_user != user_id:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Return limited data for non-admins
    user = USERS[user_id].copy()
    if current_user != "admin":
        del user["ssn"]  # Don't expose SSN
    
    return user

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8000)
```

### Test Commands

```bash
# Start server
python demo4_server.py &

# Test vulnerable endpoint (Alice accessing Bob's data)
echo "=== VULNERABLE ENDPOINT ==="
echo "Alice requesting Bob's profile (should fail, but doesn't):"
curl -s http://localhost:8000/api/v1/users/2/unsafe
# Returns Bob's data including SSN - IDOR vulnerability!

echo ""
echo "=== SECURE ENDPOINT ==="
echo "Alice requesting Bob's profile:"
curl -s -H "Authorization: Bearer token_alice" \
    http://localhost:8000/api/v1/users/2/secure
# Returns 403 Forbidden

echo ""
echo "Alice requesting her own profile:"
curl -s -H "Authorization: Bearer token_alice" \
    http://localhost:8000/api/v1/users/1/secure
# Returns Alice's data (without SSN)
```

### Expected Output

```
=== VULNERABLE ENDPOINT ===
Alice requesting Bob's profile (should fail, but doesn't):
{"id":2,"username":"bob","email":"bob@example.com","ssn":"987-65-4321"}
^^^ BOB'S SSN LEAKED!

=== SECURE ENDPOINT ===
Alice requesting Bob's profile:
{"detail":"Access denied"}
^^^ Properly blocked

Alice requesting her own profile:
{"id":1,"username":"alice","email":"alice@example.com"}
^^^ Her own data, SSN excluded
```

---

## Demo Cleanup Script

```bash
#!/bin/bash
# cleanup-demos.sh - Clean up all demo environments

echo "Cleaning up demo environments..."

# Demo 1: SQL Injection
rm -rf /tmp/sql-injection-demo

# Demo 2: Secrets
rm -rf /tmp/secrets-demo

# Demo 3: Package check (no cleanup needed)

# Demo 4: Kill FastAPI server
pkill -f "demo4_server.py" 2>/dev/null

echo "Cleanup complete."
```

---

## Verification Checklist

Before running demos:

- [ ] **Isolated environment prepared** - No production access
- [ ] **Synthetic data only** - No real credentials or PII
- [ ] **Demo scripts tested** - Verified they work as expected
- [ ] **Cleanup script ready** - Can remove all traces after demo
- [ ] **Audience understands context** - Know this is for training

After running demos:

- [ ] **All demo environments cleaned up**
- [ ] **No test credentials left behind**
- [ ] **Lessons documented** - Team understands the vulnerabilities
- [ ] **Action items assigned** - Fix any similar issues in real code

---

## References

- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [gitleaks Documentation](https://github.com/gitleaks/gitleaks)
- [FastAPI Security](https://fastapi.tiangolo.com/tutorial/security/)
